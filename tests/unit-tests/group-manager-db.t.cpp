/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/**
 * Copyright (c) 2014-2015,  Regents of the University of California
 *
 * This file is part of ndn-group-encrypt (Group-based Encryption Protocol for NDN).
 * See AUTHORS.md for complete list of ndn-group-encrypt authors and contributors.
 *
 * ndn-group-encrypt is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * ndn-group-encrypt is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * ndn-group-encrypt, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Zhiyi Zhang <dreamerbarrychang@gmail.com>
 */

#include "group-manager-db.hpp"
#include "algo/rsa.hpp"
#include "boost-test.hpp"

#include <boost/filesystem.hpp>

namespace ndn {
namespace gep {
namespace tests {

// const uint8_t DATA[] = {
// 0x06, 0xfd, 0x02, 0xd7, 0x07, 0x38, 0x08, 0x03, 0x6e, 0x64, 0x6e, 0x08, 0x03, 0x4b, 0x45,
// 0x59, 0x08, 0x05, 0x73, 0x69, 0x74, 0x65, 0x31, 0x08, 0x11, 0x6b, 0x73, 0x6b, 0x2d, 0x31,
// 0x34, 0x31, 0x36, 0x34, 0x32, 0x35, 0x33, 0x37, 0x37, 0x30, 0x39, 0x34, 0x08, 0x07, 0x49,
// 0x44, 0x2d, 0x43, 0x45, 0x52, 0x54, 0x08, 0x09, 0xfd, 0x00, 0x00, 0x01, 0x49, 0xc9, 0x8b,
// 0x2e, 0x73, 0x14, 0x03, 0x18, 0x01, 0x02, 0x15, 0xfd, 0x01, 0x61, 0x30, 0x82, 0x01, 0x5d,
// 0x30, 0x22, 0x18, 0x0f, 0x32, 0x30, 0x31, 0x34, 0x31, 0x31, 0x31, 0x39, 0x31, 0x39, 0x33,
// 0x33, 0x30, 0x32, 0x5a, 0x18, 0x0f, 0x32, 0x30, 0x31, 0x35, 0x31, 0x31, 0x31, 0x39, 0x31,
// 0x39, 0x33, 0x33, 0x30, 0x32, 0x5a, 0x30, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x29,
// 0x13, 0x0a, 0x2f, 0x6e, 0x64, 0x6e, 0x2f, 0x73, 0x69, 0x74, 0x65, 0x31, 0x30, 0x82, 0x01,
// 0x20, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
// 0x00, 0x03, 0x82, 0x01, 0x0d, 0x00, 0x30, 0x82, 0x01, 0x08, 0x02, 0x82, 0x01, 0x01, 0x00,
// 0xb6, 0x54, 0x7e, 0xe8, 0xf2, 0x91, 0x7d, 0xc1, 0x6d, 0xcb, 0x25, 0x44, 0x97, 0x90, 0xdc,
// 0x78, 0x15, 0x0e, 0xef, 0xb5, 0xe7, 0xfd, 0x09, 0x2c, 0xf8, 0xd5, 0x9c, 0x2f, 0xe5, 0xa6,
// 0xae, 0x9d, 0x7e, 0x95, 0x2d, 0xfc, 0xc7, 0xc3, 0x43, 0x46, 0xb0, 0x6f, 0x53, 0xcd, 0xcd,
// 0x6a, 0x29, 0x1d, 0x95, 0xa1, 0x62, 0xcd, 0xa9, 0xf2, 0xf8, 0xe2, 0xfa, 0x8b, 0x5d, 0xfe,
// 0xa1, 0x2b, 0x15, 0x3f, 0x7f, 0x71, 0xe6, 0x3e, 0xb9, 0xb1, 0x29, 0xd1, 0x22, 0x6f, 0x56,
// 0xdf, 0xb6, 0x85, 0xaf, 0xd4, 0xb3, 0x67, 0x8b, 0x94, 0xb8, 0x83, 0xcb, 0x72, 0x86, 0xc4,
// 0xf2, 0x86, 0xb2, 0x7c, 0x94, 0xbc, 0x38, 0x7b, 0x8c, 0x92, 0x86, 0x36, 0x83, 0x0e, 0x11,
// 0x8c, 0x95, 0x49, 0xff, 0xcc, 0x16, 0x62, 0xdb, 0x55, 0x40, 0x7f, 0xc8, 0x8d, 0xe4, 0x3f,
// 0x87, 0x02, 0x87, 0xaf, 0xf6, 0x2f, 0x8a, 0x7d, 0x74, 0x10, 0xd3, 0xbb, 0xa3, 0xfe, 0x5a,
// 0x7b, 0x8f, 0x56, 0x09, 0x8b, 0x49, 0x46, 0x9f, 0x7d, 0x55, 0xa3, 0x4a, 0xe8, 0x22, 0x7b,
// 0x80, 0x8a, 0x6f, 0xde, 0x9f, 0xfb, 0x2f, 0xeb, 0xf7, 0x29, 0x8a, 0x38, 0x67, 0x41, 0xae,
// 0x21, 0x7a, 0xe3, 0x7b, 0x96, 0x1a, 0x90, 0x35, 0x7d, 0x04, 0xaa, 0x4d, 0x9f, 0xe6, 0xd6,
// 0x00, 0x17, 0x4e, 0x02, 0x34, 0x6c, 0x56, 0x3a, 0x81, 0x3c, 0xb4, 0x7f, 0x98, 0x48, 0x22,
// 0xa0, 0x9f, 0x53, 0x35, 0xf9, 0x4e, 0xae, 0x8f, 0xc3, 0xfa, 0x0b, 0x93, 0xd4, 0x55, 0x78,
// 0x05, 0xb0, 0x40, 0x44, 0x48, 0x74, 0xb7, 0x9b, 0x2d, 0x65, 0xf0, 0x3d, 0x2e, 0x87, 0x2b,
// 0x48, 0x29, 0x12, 0x85, 0xf0, 0xaf, 0xc4, 0xdc, 0x73, 0xce, 0x18, 0x8b, 0xd9, 0x4c, 0x60,
// 0x15, 0x51, 0xae, 0x47, 0x1e, 0x2b, 0x54, 0xde, 0xf6, 0xba, 0x77, 0x30, 0x5d, 0x68, 0x9a,
// 0xfb, 0x02, 0x01, 0x11, 0x16, 0x2d, 0x1b, 0x01, 0x01, 0x1c, 0x28, 0x07, 0x26, 0x08, 0x03,
// 0x6e, 0x64, 0x6e, 0x08, 0x03, 0x4b, 0x45, 0x59, 0x08, 0x11, 0x6b, 0x73, 0x6b, 0x2d, 0x31,
// 0x34, 0x31, 0x36, 0x34, 0x32, 0x35, 0x32, 0x39, 0x35, 0x35, 0x34, 0x36, 0x08, 0x07, 0x49,
// 0x44, 0x2d, 0x43, 0x45, 0x52, 0x54, 0x17, 0xfd, 0x01, 0x00, 0x26, 0x40, 0xbc, 0xf0, 0x28,
// 0x12, 0x69, 0x94, 0x11, 0x13, 0xff, 0x47, 0x2c, 0x6b, 0x12, 0xdd, 0xfa, 0x60, 0x92, 0xe9,
// 0x59, 0x10, 0x98, 0xd8, 0x11, 0x2a, 0xf0, 0x25, 0xb0, 0x03, 0xb2, 0xda, 0xd3, 0xb6, 0xa9,
// 0xfb, 0x8b, 0xc3, 0x6f, 0xfb, 0xb4, 0x93, 0x9b, 0x24, 0x9f, 0x7e, 0x63, 0x8a, 0x37, 0xea,
// 0x88, 0x74, 0xac, 0x0c, 0x04, 0x5b, 0xa2, 0x39, 0x0c, 0xa1, 0x9e, 0x0e, 0xa2, 0xd6, 0x74,
// 0xca, 0xc4, 0x92, 0x64, 0x9f, 0xc2, 0x68, 0x56, 0xef, 0xc5, 0x11, 0xe8, 0x7a, 0xf3, 0x21,
// 0xde, 0x88, 0x40, 0x70, 0x2b, 0x44, 0xe0, 0xcb, 0x3b, 0x33, 0xc6, 0x53, 0x65, 0x70, 0x56,
// 0x08, 0xe2, 0x22, 0x70, 0x9e, 0xe0, 0x38, 0x18, 0xa8, 0x7c, 0x7d, 0x09, 0x15, 0xac, 0xf1,
// 0x44, 0x63, 0x5d, 0xd5, 0x59, 0xf4, 0xeb, 0x60, 0x6c, 0x6e, 0x77, 0x36, 0x20, 0x2a, 0xe2,
// 0xd1, 0x2d, 0xa1, 0x7d, 0xd4, 0x6d, 0x29, 0x2d, 0x88, 0xde, 0x9e, 0xf8, 0x64, 0x41, 0x6a,
// 0xeb, 0x9f, 0x3b, 0x52, 0x06, 0xb1, 0x94, 0x09, 0x3b, 0xc9, 0xba, 0xa0, 0x05, 0x31, 0x2d,
// 0x49, 0x17, 0x5b, 0xc1, 0x62, 0xf5, 0x19, 0xce, 0x27, 0x7b, 0xe8, 0x4b, 0xeb, 0x80, 0x36,
// 0xf3, 0xd7, 0xe9, 0x59, 0x22, 0x50, 0x5a, 0x14, 0xb0, 0x1a, 0xa5, 0x6b, 0x33, 0xb2, 0x83,
// 0x72, 0x11, 0xf4, 0xd5, 0xd2, 0x32, 0x93, 0x94, 0xb6, 0x8d, 0xed, 0xcd, 0xce, 0x54, 0x79,
// 0xe8, 0xc3, 0x3c, 0xa8, 0xc6, 0x71, 0xa7, 0x61, 0xba, 0x70, 0x44, 0x94, 0xc9, 0xfc, 0xd0,
// 0x20, 0x00, 0x87, 0xdc, 0xf3, 0x3c, 0x47, 0x1b, 0x4f, 0x91, 0x4c, 0xc7, 0x49, 0xb7, 0xe4,
// 0xe3, 0x84, 0xb7, 0x82, 0x52, 0xec, 0x91, 0xa9, 0x28, 0x38, 0x2d, 0x48, 0x89, 0xc7, 0xcf,
// 0xfa, 0x63, 0x0b, 0xf0, 0x62, 0x51, 0xac, 0xe9, 0xdb, 0xfd, 0x1c
// };

const uint8_t SCHEDULE[] = {
  0x8f, 0xc4,// Schedule
  0x8d, 0x90,// WhiteIntervalList
  0x8c, 0x2e, // RepetitiveInterval
    0x86, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x35, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x87, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x38, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x88, 0x01,
      0x05,
    0x89, 0x01,
      0x0a,
    0x8a, 0x01,
      0x02,
    0x8b, 0x01,
      0x01,
  0x8c, 0x2e, // RepetitiveInterval
    0x86, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x35, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x87, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x38, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x88, 0x01,
      0x06,
    0x89, 0x01,
      0x08,
    0x8a, 0x01,
      0x01,
    0x8b, 0x01,
      0x01,
  0x8c, 0x2e, // RepetitiveInterval
    0x86, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x35, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x87, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x35, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x88, 0x01,
      0x04,
    0x89, 0x01,
      0x07,
    0x8a, 0x01,
      0x00,
    0x8b, 0x01,
      0x00,
  0x8e, 0x30, // BlackIntervalList
  0x8c, 0x2e, // RepetitiveInterval
     0x86, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x37, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x87, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x37, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x88, 0x01,
      0x07,
    0x89, 0x01,
      0x08,
    0x8a, 0x01,
      0x00,
    0x8b, 0x01,
      0x00
};

const uint8_t REPETITIVE_INTERVAL[] = {
  0x8c, 0x2e, // RepetitiveInterval
    0x86, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x38, 0x32, 0x35, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x87, 0x0f,
      0x32, 0x30, 0x31, 0x35, 0x30, 0x39, 0x32, 0x31, 0x54, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x88, 0x01,
      0x02,
    0x89, 0x01,
      0x0a,
    0x8a, 0x01,
      0x05,
    0x8b, 0x01,
      0x01
};

class GroupManagerDBFixture
{
public:
  GroupManagerDBFixture()
    : tmpPath(boost::filesystem::path(TMP_TESTS_PATH))
  {
    boost::filesystem::create_directories(tmpPath);
  }

  ~GroupManagerDBFixture()
  {
    boost::filesystem::remove_all(tmpPath);
  }

public:
  boost::filesystem::path tmpPath;
};

BOOST_FIXTURE_TEST_SUITE(TestGroupManagerDB, GroupManagerDBFixture)

BOOST_AUTO_TEST_CASE(DatabaseFunctions)
{
  // construction
  std::string dbDir = tmpPath.c_str();
  dbDir += "/test.db";
  GroupManagerDB db(dbDir);

  Block scheduleBlock(SCHEDULE, sizeof(SCHEDULE));

  // create schedule
  Schedule schedule(scheduleBlock);

  // create member
  RandomNumberGenerator rng;
  RsaKeyParams params;
  DecryptKey<algo::Rsa> decryptKey = algo::Rsa::generateKey(rng, params);
  EncryptKey<algo::Rsa> encryptKey = algo::Rsa::deriveEncryptKey(decryptKey.getKeyBits());
  Buffer keyBuf = encryptKey.getKeyBits();

  Name name1("/ndn/BoyA/ksk-123");
  Name name2("/ndn/BoyB/ksk-1233");
  Name name3("/ndn/GirlC/ksk-123");
  Name name4("/ndn/GirlD/ksk-123");
  Name name5("/ndn/Hello/ksk-123");

  // add schedules into the database
  BOOST_CHECK_NO_THROW(db.addSchedule("work-time", schedule));
  BOOST_CHECK_NO_THROW(db.addSchedule("rest-time", schedule));
  BOOST_CHECK_NO_THROW(db.addSchedule("play-time", schedule));
  BOOST_CHECK_NO_THROW(db.addSchedule("boelter-time", schedule));

  // throw exception when adding a schedule called an existing name
  BOOST_CHECK_THROW(db.addSchedule("boelter-time", schedule), GroupManagerDB::Error);

  // add members into the database
  BOOST_CHECK_NO_THROW(db.addMember("work-time", name1, keyBuf));
  BOOST_CHECK_NO_THROW(db.addMember("rest-time", name2, keyBuf));
  BOOST_CHECK_NO_THROW(db.addMember("play-time", name3, keyBuf));
  BOOST_CHECK_NO_THROW(db.addMember("play-time", name4, keyBuf));

  // throw exception when adding a member having a not existing schedule name
  BOOST_CHECK_THROW(db.addMember("false-time", name5, keyBuf), GroupManagerDB::Error);

  BOOST_CHECK_NO_THROW(db.addMember("boelter-time", name5, keyBuf));

  // throw exception when adding a member having an existing identity
  BOOST_CHECK_THROW(db.addMember("work-time", name5, keyBuf), GroupManagerDB::Error);

  // has function
  BOOST_CHECK_EQUAL(db.hasSchedule("work-time"), true);
  BOOST_CHECK_EQUAL(db.hasSchedule("rest-time"), true);
  BOOST_CHECK_EQUAL(db.hasSchedule("play-time"), true);
  BOOST_CHECK_EQUAL(db.hasSchedule("sleep-time"), false);
  BOOST_CHECK_EQUAL(db.hasSchedule(""), false);

  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/BoyA")), true);
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/BoyB")), true);
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/BoyC")), false);

  // get schedule
  Schedule scheduleResult = db.getSchedule("work-time");
  BOOST_CHECK(scheduleResult.wireEncode() == scheduleBlock);

  scheduleResult = db.getSchedule("play-time");
  BOOST_CHECK(scheduleResult.wireEncode() == scheduleBlock);

  // throw exception when there is no such schedule in database
  BOOST_CHECK_THROW(db.getSchedule("work-time-11"), GroupManagerDB::Error);

  // list all schedule names
  std::list<std::string> names = db.listAllScheduleNames();
  BOOST_CHECK(std::find(names.begin(), names.end(), "work-time") != names.end());
  BOOST_CHECK(std::find(names.begin(), names.end(), "play-time") != names.end());
  BOOST_CHECK(std::find(names.begin(), names.end(), "rest-time") != names.end());
  BOOST_CHECK(std::find(names.begin(), names.end(), "sleep-time") == names.end());

  // list members of a schedule
  std::map<Name, Buffer> memberMap = db.getScheduleMembers("play-time");
  BOOST_CHECK(memberMap.size() != 0);

  // when there's no such schedule, the return list's size is 0
  BOOST_CHECK_EQUAL(db.getScheduleMembers("sleep-time").size(), 0);

  // list all members
  std::list<Name> members = db.listAllMembers();
  BOOST_CHECK(std::find(members.begin(), members.end(), Name("/ndn/GirlC")) != members.end());
  BOOST_CHECK(std::find(members.begin(), members.end(), Name("/ndn/GirlD")) != members.end());
  BOOST_CHECK(std::find(members.begin(), members.end(), Name("/ndn/BoyA")) != members.end());
  BOOST_CHECK(std::find(members.begin(), members.end(), Name("/ndn/BoyB")) != members.end());

  // rename schedule
  BOOST_CHECK_EQUAL(db.hasSchedule("boelter-time"), true);
  db.renameSchedule("boelter-time", "rieber-time");
  BOOST_CHECK_EQUAL(db.hasSchedule("boelter-time"), false);
  BOOST_CHECK_EQUAL(db.hasSchedule("rieber-time"), true);
  BOOST_CHECK_EQUAL(db.getMemberSchedule("/ndn/Hello"), "rieber-time");

  // update schedule
  Schedule newSchedule(scheduleBlock);
  Block repIntervalBlock(REPETITIVE_INTERVAL, sizeof(REPETITIVE_INTERVAL));
  newSchedule.addWhiteInterval(RepetitiveInterval(repIntervalBlock));
  db.updateSchedule("rieber-time", newSchedule);
  scheduleResult = db.getSchedule("rieber-time");
  BOOST_CHECK(scheduleResult.wireEncode() != scheduleBlock);
  BOOST_CHECK(scheduleResult.wireEncode() == newSchedule.wireEncode());

  // add a new schedule when update a not existing schedule
  BOOST_CHECK_EQUAL(db.hasSchedule("ralphs-time"), false);
  db.updateSchedule("ralphs-time", newSchedule);
  BOOST_CHECK_EQUAL(db.hasSchedule("ralphs-time"), true);

  // update schedule of member
  db.updateMemberSchedule(Name("/ndn/Hello"), "play-time");
  BOOST_CHECK_EQUAL(db.getMemberSchedule(Name("/ndn/Hello")), "play-time");

  // delete member
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/Hello")), true);
  db.deleteMember(Name("/ndn/Hello"));
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/Hello")), false);

  // delete a not existing member
  BOOST_CHECK_NO_THROW(db.deleteMember(Name("/ndn/notExisting")));

  // delete the schedule and all the members using this schedule should be deleted
  db.deleteSchedule("play-time");
  BOOST_CHECK_EQUAL(db.hasSchedule("play-time"), false);
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/GirlC")), false);
  BOOST_CHECK_EQUAL(db.hasMember(Name("/ndn/GirlD")), false);

  // delete a not existing schedule
  BOOST_CHECK_NO_THROW(db.deleteSchedule("not-existing-time"));
}

BOOST_AUTO_TEST_SUITE_END()

} // namespace tests
} // namespace gep
} // namespace ndn
